{
  "version": 3,
  "sources": ["../src/utils/response.util.ts", "../resources/utils/vanilla-validator.ts", "../src/constants.ts", "../resources/utils/index.ts", "../resources/auth.ts"],
  "sourcesContent": [
    "// Error names as a constant object\nexport const ERROR_NAMES = {\n    VALIDATION_ERROR: \"VALIDATION_ERROR\",\n    AUTH_ERROR: \"AUTH_ERROR\",\n    NOT_FOUND: \"NOT_FOUND\",\n    SERVER_ERROR: \"SERVER_ERROR\",\n} as const;\n\n// Type of allowed error names (derived automatically)\nexport type ERROR_NAME = typeof ERROR_NAMES[keyof typeof ERROR_NAMES];\n\n// Base structure for all responses\nexport interface BaseResponse<T = undefined> {\n    success: boolean;\n    message: string;\n    data?: T;\n}\n\nexport interface FailureResponse<T = undefined> extends BaseResponse<T> {\n    name: ERROR_NAME;\n}\n\n// Success factory\nexport function createSuccessResponse<T = undefined>(\n    message: string,\n    data?: T\n): BaseResponse<T> {\n    return {\n        success: true,\n        message,\n        ...(data !== undefined && { data }),\n    };\n}\n\n// Failure factory (type-safe error name)\nexport function createFailureResponse<T = undefined>(\n    name: ERROR_NAME,\n    message: string,\n    data?: T\n): FailureResponse<T> {\n    return {\n        success: false,\n        message,\n        name,\n        ...(data !== undefined && { data }),\n    };\n}\n",
    "// /*\n//  * Vanilla, Fully‑Typed Form Validator (TypeScript, zero‑deps)\n//  * -----------------------------------------------------------\n//  * ✓ Strong generics: typed form data + field names\n//  * ✓ Field-level + form-level (cross-field) validators\n//  * ✓ Sync + async validators (with optional debounce)\n//  * ✓ Touched/dirty tracking; validate on chosen events\n//  * ✓ Pluggable message rendering (per-field + summary)\n//  * ✓ Accessible by default (aria-invalid/aria-describedby)\n//  * ✓ Programmatic API: validate, setErrors (server), reset, getData, setValue\n//  * ✓ No frameworks, no dependencies\n//  *\n//  * Usage (Login form example):\n//  * -----------------------------------------------------------\n//  * import { createFormValidator, v } from \"./vanilla-validator\";\n//  *\n//  * const fv = createFormValidator(\n//  *   {\n//  *     form: \"#login-form\",\n//  *     errorSummary: \"#form-errors\",\n//  *     validateOnSubmit: true,\n//  *     scrollToFirstError: true,\n//  *   },\n//  *   {\n//  *     email: {\n//  *       selector: 'input[type=\"email\"], input[name=\"email\"]',\n//  *       validateOn: [\"input\", \"blur\"],\n//  *       validators: [v.required(), v.email()],\n//  *     },\n//  *     password: {\n//  *       selector: 'input[type=\"password\"]',\n//  *       validateOn: [\"input\", \"blur\"],\n//  *       validators: [\n//  *         v.required(),\n//  *         v.minLength(8),\n//  *         v.passwordRules({\n//  *           upper: true, lower: true, digit: true, special: true,\n//  *         }),\n//  *       ],\n//  *     },\n//  *   } as const\n//  * );\n//  *\n//  * // Submit flow (example):\n//  * document.querySelector('#login-form')!.addEventListener('submit', async (e) => {\n//  *   e.preventDefault();\n//  *   const ok = await fv.validateForm();\n//  *   if (!ok) return;\n//  *\n//  *   const body = fv.getData();\n//  *   const res = await fetch('/auth/login', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) });\n//  *   const json = await res.json();\n//  *   if (!res.ok) {\n//  *     // Support either field-specific or global messages\n//  *     // e.g. { fieldErrors: { email: [\"Bad email\"] }, formErrors: [\"Invalid user\"] }\n//  *     fv.setErrors(json.fieldErrors || {}, json.formErrors || []);\n//  *     return;\n//  *   }\n//  *   window.location.href = '/dashboard';\n//  * });\n//  */\n\n// // -----------------------------------------------------------\n// // Types\n// // -----------------------------------------------------------\n// export type MaybePromise<T> = T | Promise<T>;\n\n// export type ValidationResult =\n//     | { valid: true }\n//     | { valid: false; message: string; code?: string };\n\n// export type ValidatorFn<TForm, TValue = unknown> = (ctx: {\n//     name: keyof TForm & string;\n//     value: TValue;\n//     formData: Readonly<TForm>;\n//     fieldEl: HTMLElement | null;\n//     formEl: HTMLFormElement | null;\n// }) => MaybePromise<ValidationResult>;\n\n// export type FormValidatorFn<TForm> = (ctx: {\n//     formData: Readonly<TForm>;\n//     formEl: HTMLFormElement | null;\n// }) => MaybePromise<ValidationResult[]>; // multiple messages allowed at form-level\n\n// export type ValueGetter<TValue> = (el: HTMLElement | null) => TValue;\n// export type ValueSetter<TValue> = (el: HTMLElement | null, v: TValue) => void;\n\n// export type FieldConfig<TForm, TValue = unknown> = {\n//     selector: string | HTMLElement;\n//     validators?: ValidatorFn<TForm, TValue>[];\n//     // Which DOM events should trigger validation for this field\n//     validateOn?: Array<\"input\" | \"change\" | \"blur\">;\n//     // Debounce async/sync validators per field (ms)\n//     debounceMs?: number;\n//     // Optional custom value coercion\n//     getValue?: ValueGetter<TValue>;\n//     setValue?: ValueSetter<TValue>;\n//     // Where/how to show messages for this field\n//     messageTarget?: string | HTMLElement | ((args: MessageRenderArgs) => void);\n//     // If true, will set aria-invalid and link message with aria-describedby\n//     a11y?: boolean;\n// };\n\n// export type MessageRenderArgs = {\n//     name: string;\n//     messages: string[]; // resolved for the field\n//     fieldEl: HTMLElement | null;\n//     formEl: HTMLFormElement | null;\n// };\n\n// export type FormConfig<TForm> = {\n//     form: string | HTMLFormElement;\n//     errorSummary?: string | HTMLElement | ((formMessages: string[], formEl: HTMLFormElement | null) => void);\n//     validateOnSubmit?: boolean; // default true\n//     preventSubmitIfInvalid?: boolean; // default true\n//     scrollToFirstError?: boolean; // default false\n//     classes?: Partial<{\n//         fieldInvalid: string; // applied to field element on invalid\n//         fieldValid: string;   // applied to field element on valid\n//         fieldTouched: string; // applied once user interacted\n//     }>;\n// };\n\n// export type FieldState = {\n//     touched: boolean;\n//     dirty: boolean;\n//     messages: string[];\n//     validating: boolean;\n//     valid: boolean; // latest\n// };\n\n// export type CreatedFormValidator<TForm> = {\n//     // read-only snapshot\n//     readonly formEl: HTMLFormElement | null;\n//     readonly fields: Readonly<Record<keyof TForm & string, HTMLElement | null>>;\n\n//     validateField: (name: keyof TForm & string) => Promise<boolean>;\n//     validateForm: () => Promise<boolean>;\n\n//     setErrors: (\n//         fieldErrors: Partial<Record<keyof TForm & string, string[]>>, // server field errors\n//         formErrors?: string[]\n//     ) => void;\n\n//     clearErrors: () => void;\n\n//     getData: () => TForm;\n//     setValue: <K extends keyof TForm & string>(name: K, value: TForm[K]) => void;\n\n//     touch: (name: keyof TForm & string) => void;\n//     reset: () => void;\n//     destroy: () => void;\n// };\n\n// // -----------------------------------------------------------\n// // Utilities\n// // -----------------------------------------------------------\n// const isHTMLElement = (o: any): o is HTMLElement => o && typeof o === \"object\" && \"nodeType\" in o;\n// const el = <T extends HTMLElement>(root: ParentNode, sel: string): T | null => root.querySelector(sel);\n// const asEl = (x: string | HTMLElement | null | undefined): HTMLElement | null =>\n//     !x ? null : typeof x === \"string\" ? document.querySelector(x) : x;\n\n// const DEFAULT_CLASSES = {\n//     fieldInvalid: \"fv-invalid\",\n//     fieldValid: \"fv-valid\",\n//     fieldTouched: \"fv-touched\",\n// };\n\n// const DEFAULT_SUMMARY_RENDERER = (summaryEl: HTMLElement | null, messages: string[]) => {\n//     if (!summaryEl) return;\n//     const isList = summaryEl.tagName === \"UL\" || summaryEl.tagName === \"OL\";\n//     summaryEl.classList.toggle(\"hidden\", messages.length === 0);\n//     if (isList) {\n//         summaryEl.innerHTML = messages.map((m) => `<li>${m}</li>`).join(\"\");\n//     } else {\n//         summaryEl.innerHTML = messages.join(\"<br>\");\n//     }\n// };\n\n// const DEFAULT_FIELD_RENDERER = (target: HTMLElement | null, messages: string[]) => {\n//     if (!target) return;\n//     const isList = target.tagName === \"UL\" || target.tagName === \"OL\";\n//     target.classList.toggle(\"hidden\", messages.length === 0);\n//     if (isList) {\n//         target.innerHTML = messages.map((m) => `<li>${m}</li>`).join(\"\");\n//     } else {\n//         target.innerHTML = messages.join(\"<br>\");\n//     }\n// };\n\n// const debounce = <T extends (...args: any[]) => any>(fn: T, ms = 200) => {\n//     let t: number | undefined;\n//     const debounced = (...args: Parameters<T>) => {\n//         if (t) window.clearTimeout(t);\n//         t = window.setTimeout(() => fn(...args), ms);\n//     };\n//     (debounced as any).flush = () => { if (t) { window.clearTimeout(t); t = undefined; fn(); } };\n//     return debounced as T & { flush: () => void };\n// };\n\n// // -----------------------------------------------------------\n// // Core factory\n// // -----------------------------------------------------------\n// export function createFormValidator<TForm extends Record<string, any>>(\n//     formConfig: FormConfig<TForm>,\n//     fieldsConfig: { [K in keyof TForm & string]: FieldConfig<TForm, TForm[K]> }\n// ): CreatedFormValidator<TForm> {\n//     const formEl = asEl(formConfig.form) as HTMLFormElement | null;\n//     const classes = { ...DEFAULT_CLASSES, ...(formConfig.classes || {}) };\n//     const validateOnSubmit = formConfig.validateOnSubmit !== false; // default true\n//     const preventSubmitIfInvalid = formConfig.preventSubmitIfInvalid !== false; // default true\n\n//     // Prepare fields\n//     const fieldElements: Record<string, HTMLElement | null> = {};\n//     const fieldStates: Record<string, FieldState> = {};\n//     const fieldDebouncers: Record<string, ((() => void) & { flush: () => void }) | null> = {};\n\n//     for (const name of Object.keys(fieldsConfig)) {\n//         const cfg = fieldsConfig[name as keyof TForm & string];\n//         const target = typeof cfg.selector === \"string\" ? el<HTMLElement>(document, cfg.selector) : cfg.selector;\n//         fieldElements[name] = target ?? null;\n//         fieldStates[name] = { touched: false, dirty: false, messages: [], validating: false, valid: true };\n//         fieldDebouncers[name] = cfg.debounceMs ? debounce(() => void 0, cfg.debounceMs) : null; // placeholder; per-field we'll use inline debouncing\n//     }\n\n//     // Resolve per-field message target\n//     function resolveFieldMessageTarget(cfg: FieldConfig<TForm, any>): HTMLElement | null | ((args: MessageRenderArgs) => void) {\n//         if (!cfg.messageTarget) return null;\n//         if (typeof cfg.messageTarget === \"function\") return cfg.messageTarget;\n//         return asEl(cfg.messageTarget);\n//     }\n\n//     // Read / write values\n//     const getValue = <K extends keyof TForm & string>(name: K): TForm[K] => {\n//         const cfg = fieldsConfig[name];\n//         const elRef = fieldElements[name];\n//         if (cfg.getValue) return cfg.getValue(elRef);\n//         if (!elRef) return undefined as unknown as TForm[K];\n//         // default coercion for common input types\n//         if (elRef instanceof HTMLInputElement) {\n//             const type = elRef.type;\n//             if (type === \"checkbox\") return (!!elRef.checked) as unknown as TForm[K];\n//             if (type === \"number\" || type === \"range\") return (elRef.value === \"\" ? undefined : Number(elRef.value)) as unknown as TForm[K];\n//             return elRef.value as unknown as TForm[K];\n//         }\n//         if (elRef instanceof HTMLTextAreaElement) return elRef.value as unknown as TForm[K];\n//         if (elRef instanceof HTMLSelectElement) return elRef.value as unknown as TForm[K];\n//         return (elRef as any).value as TForm[K];\n//     };\n\n//     const setValue = <K extends keyof TForm & string>(name: K, value: TForm[K]) => {\n//         const cfg = fieldsConfig[name];\n//         const elRef = fieldElements[name];\n//         if (cfg.setValue) return cfg.setValue(elRef, value);\n//         if (!elRef) return;\n//         if (elRef instanceof HTMLInputElement || elRef instanceof HTMLTextAreaElement || elRef instanceof HTMLSelectElement) {\n//             if ((elRef as HTMLInputElement).type === \"checkbox\" && typeof value === \"boolean\") {\n//                 (elRef as HTMLInputElement).checked = value;\n//             } else {\n//                 (elRef as any).value = value as any;\n//             }\n//         } else {\n//             (elRef as any).value = value as any;\n//         }\n//     };\n\n//     const getFormData = (): TForm => {\n//         const data = {} as TForm;\n//         for (const name of Object.keys(fieldsConfig) as Array<keyof TForm & string>) {\n//             (data as any)[name] = getValue(name);\n//         }\n//         return data;\n//     };\n\n//     // Rendering helpers\n//     const summaryTarget = typeof formConfig.errorSummary === \"function\" || !formConfig.errorSummary\n//         ? formConfig.errorSummary\n//         : asEl(formConfig.errorSummary);\n\n//     function renderSummary(messages: string[]) {\n//         if (typeof summaryTarget === \"function\") {\n//             summaryTarget(messages, formEl);\n//         } else {\n//             DEFAULT_SUMMARY_RENDERER(summaryTarget as HTMLElement | null, messages);\n//         }\n//     }\n\n//     function renderField(name: string) {\n//         const cfg = fieldsConfig[name as keyof TForm & string];\n//         const target = resolveFieldMessageTarget(cfg);\n//         const messages = fieldStates[name].messages;\n\n//         const fieldEl = fieldElements[name];\n//         if (cfg.a11y !== false && fieldEl) {\n//             fieldEl.setAttribute(\"aria-invalid\", String(messages.length > 0));\n//             // link describedby if we have an element target\n//             if (target && isHTMLElement(target)) {\n//                 const id = target.id || `${String(name)}-error`;\n//                 target.id = id;\n//                 fieldEl.setAttribute(\"aria-describedby\", id);\n//             }\n//         }\n\n//         if (typeof target === \"function\") {\n//             target({ name, messages, fieldEl, formEl });\n//         } else {\n//             DEFAULT_FIELD_RENDERER(target as HTMLElement | null, messages);\n//         }\n\n//         // Classes\n//         if (fieldEl) {\n//             fieldEl.classList.toggle(classes.fieldInvalid, messages.length > 0);\n//             fieldEl.classList.toggle(classes.fieldValid, messages.length === 0 && fieldStates[name].touched);\n//         }\n//     }\n\n//     function collectAllMessages(): string[] {\n//         const msgs: string[] = [];\n//         for (const name of Object.keys(fieldStates)) {\n//             msgs.push(...fieldStates[name].messages);\n//         }\n//         return msgs;\n//     }\n\n//     async function runValidatorsForField(name: keyof TForm & string): Promise<string[]> {\n//         const cfg = fieldsConfig[name];\n//         const validators = cfg.validators || [];\n//         const value = getValue(name);\n//         const formData = getFormData();\n//         const fieldEl = fieldElements[name];\n\n//         const messages: string[] = [];\n//         for (const fn of validators) {\n//             const res = await fn({ name, value, formData, fieldEl, formEl });\n//             if (!res || res.valid === true) continue;\n//             messages.push(res.message);\n//         }\n//         return messages;\n//     }\n\n//     async function validateField(name: keyof TForm & string): Promise<boolean> {\n//         const cfg = fieldsConfig[name];\n//         const state = fieldStates[name];\n\n//         state.touched = true;\n//         const exec = async () => {\n//             state.validating = true;\n//             const messages = await runValidatorsForField(name);\n//             state.messages = messages;\n//             state.valid = messages.length === 0;\n//             state.validating = false;\n//             renderField(name);\n//             renderSummary(collectAllMessages());\n//             return state.valid;\n//         };\n\n//         if (cfg.debounceMs && cfg.debounceMs > 0) {\n//             return new Promise((resolve) => {\n//                 const d = debounce(async () => resolve(await exec()), cfg.debounceMs);\n//                 d();\n//             });\n//         }\n//         return exec();\n//     }\n\n//     async function validateForm(): Promise<boolean> {\n//         const results = await Promise.all(\n//             (Object.keys(fieldsConfig) as Array<keyof TForm & string>).map((n) => validateField(n))\n//         );\n\n//         // Run form-level validators (cross-field) if provided\n//         let formLevelMessages: string[] = [];\n//         if (typeof (formConfig as any).formValidators === \"function\") {\n//             const res = await (formConfig as any).formValidators({ formData: getFormData(), formEl });\n//             if (Array.isArray(res)) {\n//                 for (const r of res) if (r && r.valid === false) formLevelMessages.push(r.message);\n//             }\n//         }\n\n//         const allMessages = collectAllMessages();\n//         allMessages.push(...formLevelMessages);\n//         renderSummary(allMessages);\n\n//         if (formConfig.scrollToFirstError && allMessages.length > 0) {\n//             const firstInvalid = Object.keys(fieldStates).find((n) => fieldStates[n].messages.length > 0);\n//             const elRef = firstInvalid ? fieldElements[firstInvalid] : null;\n//             elRef?.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n//             elRef?.focus({ preventScroll: true });\n//         }\n\n//         return results.every(Boolean) && formLevelMessages.length === 0;\n//     }\n\n//     function setErrors(\n//         fieldErrors: Partial<Record<keyof TForm & string, string[]>>,\n//         formErrors: string[] = []\n//     ) {\n//         // Assign messages\n//         for (const name of Object.keys(fieldsConfig) as Array<keyof TForm & string>) {\n//             const msgs = fieldErrors[name] || [];\n//             fieldStates[name].messages = msgs;\n//             fieldStates[name].valid = msgs.length === 0;\n//             // Mark as touched so styling appears\n//             fieldStates[name].touched = true;\n//             renderField(name);\n//         }\n//         const all = collectAllMessages();\n//         all.push(...formErrors);\n//         renderSummary(all);\n//     }\n\n//     function clearErrors() {\n//         for (const name of Object.keys(fieldStates)) {\n//             fieldStates[name].messages = [];\n//             fieldStates[name].valid = true;\n//             renderField(name);\n//         }\n//         renderSummary([]);\n//     }\n\n//     function touch(name: keyof TForm & string) {\n//         fieldStates[name].touched = true;\n//         const elRef = fieldElements[name];\n//         elRef?.classList.add(classes.fieldTouched);\n//     }\n\n//     function reset() {\n//         for (const name of Object.keys(fieldStates)) {\n//             fieldStates[name] = { touched: false, dirty: false, messages: [], validating: false, valid: true };\n//             renderField(name);\n//         }\n//         renderSummary([]);\n//     }\n\n//     function destroy() {\n//         // remove listeners\n//         if (formEl && validateOnSubmit && preventSubmitIfInvalid) {\n//             formEl.removeEventListener(\"submit\", onSubmit);\n//         }\n//         for (const name of Object.keys(fieldsConfig) as Array<keyof TForm & string>) {\n//             const elRef = fieldElements[name];\n//             const cfg = fieldsConfig[name];\n//             const bound = boundHandlers[name];\n//             if (elRef && bound) {\n//                 for (const ev of cfg.validateOn || []) {\n//                     elRef.removeEventListener(ev, bound);\n//                 }\n//             }\n//         }\n//     }\n\n//     // Event binding\n//     const boundHandlers: Record<string, (e: Event) => void> = {};\n//     for (const name of Object.keys(fieldsConfig) as Array<keyof TForm & string>) {\n//         const cfg = fieldsConfig[name];\n//         const elRef = fieldElements[name];\n//         if (!elRef) continue;\n\n//         const handler = async () => {\n//             touch(name);\n//             await validateField(name);\n//         };\n//         boundHandlers[name] = handler;\n\n//         for (const ev of cfg.validateOn || []) {\n//             elRef.addEventListener(ev, handler);\n//         }\n//     }\n\n//     async function onSubmit(e: Event) {\n//         if (!preventSubmitIfInvalid) return;\n//         const ok = await validateForm();\n//         if (!ok) {\n//             e.preventDefault();\n//             e.stopPropagation();\n//         }\n//     }\n\n//     if (formEl && validateOnSubmit) {\n//         formEl.addEventListener(\"submit\", onSubmit);\n//     }\n\n//     return {\n//         get formEl() { return formEl; },\n//         get fields() { return Object.fromEntries(Object.entries(fieldElements)) as any; },\n\n//         validateField: (n) => validateField(n),\n//         validateForm,\n\n//         setErrors,\n//         clearErrors,\n\n//         getData: () => getFormData(),\n//         setValue,\n\n//         touch,\n//         reset,\n//         destroy,\n//     } as const;\n// }\n\n// // -----------------------------------------------------------\n// // Built-in validators (v.*)\n// // -----------------------------------------------------------\n// export const v = {\n//     required<TForm, TValue>(message = \"This field is required.\"): ValidatorFn<TForm, TValue> {\n//         return ({ value }) => {\n//             if (value === undefined || value === null) return { valid: false, message } as const;\n//             if (typeof value === \"string\" && value.trim() === \"\") return { valid: false, message } as const;\n//             if (Array.isArray(value) && value.length === 0) return { valid: false, message } as const;\n//             return { valid: true } as const;\n//         };\n//     },\n\n//     pattern<TForm>(regex: RegExp, message = \"Invalid format.\"): ValidatorFn<TForm, string> {\n//         return ({ value }) => {\n//             if (typeof value !== \"string\") return { valid: true } as const;\n//             return regex.test(value) ? { valid: true } as const : { valid: false, message } as const;\n//         };\n//     },\n\n//     email<TForm>(message = \"Invalid email address.\"): ValidatorFn<TForm, string> {\n//         // RFC 5322-lite\n//         const re = /^(?:[a-zA-Z0-9_'^&\\-]+(?:\\.[a-zA-Z0-9_'^&\\-]+)*)@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,}$/;\n//         return ({ value }) => {\n//             if (typeof value !== \"string\" || value.trim() === \"\") return { valid: true } as const; // let required handle empties\n//             return re.test(value.trim()) ? { valid: true } as const : { valid: false, message } as const;\n//         };\n//     },\n\n//     minLength<TForm>(len: number, message?: string): ValidatorFn<TForm, string> {\n//         return ({ value }) => {\n//             if (typeof value !== \"string\") return { valid: true } as const;\n//             if (value.length < len) return { valid: false, message: message || `Must be at least ${len} characters.` } as const;\n//             return { valid: true } as const;\n//         };\n//     },\n\n//     maxLength<TForm>(len: number, message?: string): ValidatorFn<TForm, string> {\n//         return ({ value }) => {\n//             if (typeof value !== \"string\") return { valid: true } as const;\n//             if (value.length > len) return { valid: false, message: message || `Must be at most ${len} characters.` } as const;\n//             return { valid: true } as const;\n//         };\n//     },\n\n//     equalsField<TForm, K extends keyof TForm & string>(other: K, message = \"Values do not match.\"): ValidatorFn<TForm, any> {\n//         return ({ formData }) => {\n//             return { valid: true } as const; // actual comparison done below via closure\n//         };\n//     },\n\n//     sameAs<TForm, K extends keyof TForm & string>(other: K, message = \"Values do not match.\"): ValidatorFn<TForm, any> {\n//         return ({ value, formData }) => {\n//             return (value === (formData as any)[other]) ? { valid: true } as const : { valid: false, message } as const;\n//         };\n//     },\n\n//     numberRange<TForm>(min?: number, max?: number, message?: string): ValidatorFn<TForm, number | undefined> {\n//         return ({ value }) => {\n//             if (value === undefined || value === null || Number.isNaN(value)) return { valid: true } as const;\n//             if (typeof min === \"number\" && value < min) return { valid: false, message: message || `Must be ≥ ${min}.` } as const;\n//             if (typeof max === \"number\" && value > max) return { valid: false, message: message || `Must be ≤ ${max}.` } as const;\n//             return { valid: true } as const;\n//         };\n//     },\n\n//     passwordRules<TForm>(opts: { upper?: boolean; lower?: boolean; digit?: boolean; special?: boolean; minUnique?: number } = {}): ValidatorFn<TForm, string> {\n//         const re = {\n//             upper: /[A-Z]/,\n//             lower: /[a-z]/,\n//             digit: /\\d/,\n//             special: /[^A-Za-z0-9\\s]/,\n//         };\n//         return ({ value }) => {\n//             if (typeof value !== \"string\" || value.length === 0) return { valid: true } as const; // let required/minLength manage empties\n//             const missing: string[] = [];\n//             if (opts.upper && !re.upper.test(value)) missing.push(\"an uppercase letter\");\n//             if (opts.lower && !re.lower.test(value)) missing.push(\"a lowercase letter\");\n//             if (opts.digit && !re.digit.test(value)) missing.push(\"a digit\");\n//             if (opts.special && !re.special.test(value)) missing.push(\"a special character\");\n//             if (typeof opts.minUnique === \"number\") {\n//                 const unique = new Set(value.split(\"\")).size;\n//                 if (unique < opts.minUnique) missing.push(`${opts.minUnique} unique characters`);\n//             }\n//             if (missing.length) return { valid: false, message: `Password must include: ${missing.join(\", \")}.` } as const;\n//             return { valid: true } as const;\n//         };\n//     },\n\n//     custom<TForm, TValue>(fn: ValidatorFn<TForm, TValue>): ValidatorFn<TForm, TValue> { return fn; },\n// };\n\n// // -----------------------------------------------------------\n// // Optional: simple helpers to wire common per-field message containers\n// // -----------------------------------------------------------\n// export function belowFieldMessage(targetSelector: string): (args: MessageRenderArgs) => void {\n//     const targetEl = asEl(targetSelector);\n//     return ({ messages }) => DEFAULT_FIELD_RENDERER(targetEl, messages);\n// }\n\n// export function toSummary(summarySelector: string): (messages: string[], formEl: HTMLFormElement | null) => void {\n//     const summaryEl = asEl(summarySelector);\n//     return (messages) => DEFAULT_SUMMARY_RENDERER(summaryEl, messages);\n// }\n\n\n\n\n\n/*\n * Vanilla, Fully‑Typed Form Validator (TypeScript, zero‑deps)\n * -----------------------------------------------------------\n * ✓ Strong generics: typed form data + field names\n * ✓ Field-level + form-level (cross-field) validators\n * ✓ Sync + async validators (with optional debounce)\n * ✓ Touched/dirty tracking; validate on chosen events\n * ✓ Pluggable message rendering (per-field + summary)\n * ✓ Accessible by default (aria-invalid/aria-describedby)\n * ✓ Programmatic API: validate, setErrors (server), reset, getData, setValue\n * ✓ No frameworks, no dependencies\n *\n * Usage (Login form example):\n * -----------------------------------------------------------\n * import { createFormValidator, v } from \"./vanilla-validator\";\n *\n * const fv = createFormValidator(\n *   {\n *     form: \"#login-form\",\n *     errorSummary: \"#form-errors\",\n *     validateOnSubmit: true,\n *     scrollToFirstError: true,\n *   },\n *   {\n *     email: {\n *       selector: 'input[type=\"email\"], input[name=\"email\"]',\n *       validateOn: [\"input\", \"blur\"],\n *       validators: [v.required(), v.email()],\n *     },\n *     password: {\n *       selector: 'input[type=\"password\"]',\n *       validateOn: [\"input\", \"blur\"],\n *       validators: [\n *         v.required(),\n *         v.minLength(8),\n *         v.passwordRules({\n *           upper: true, lower: true, digit: true, special: true,\n *         }),\n *       ],\n *     },\n *   } as const\n * );\n *\n * // Submit flow (example):\n * document.querySelector('#login-form')!.addEventListener('submit', async (e) => {\n *   e.preventDefault();\n *   const ok = await fv.validateForm();\n *   if (!ok) return;\n *\n *   const body = fv.getData();\n *   const res = await fetch('/auth/login', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) });\n *   const json = await res.json();\n *   if (!res.ok) {\n *     // Support either field-specific or global messages\n *     // e.g. { fieldErrors: { email: [\"Bad email\"] }, formErrors: [\"Invalid user\"] }\n *     fv.setErrors(json.fieldErrors || {}, json.formErrors || []);\n *     return;\n *   }\n *   window.location.href = '/dashboard';\n * });\n */\n\n// -----------------------------------------------------------\n// Types\n// -----------------------------------------------------------\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport type ValidationResult =\n    | { valid: true }\n    | { valid: false; message: string; code?: string };\n\nexport type ValidatorFn<TForm, TValue = unknown> = (ctx: {\n    name: keyof TForm & string;\n    value: TValue;\n    formData: Readonly<TForm>;\n    fieldEl: HTMLElement | null;\n    formEl: HTMLFormElement | null;\n}) => MaybePromise<ValidationResult>;\n\nexport type FormValidatorFn<TForm> = (ctx: {\n    formData: Readonly<TForm>;\n    formEl: HTMLFormElement | null;\n}) => MaybePromise<ValidationResult[]>; // multiple messages allowed at form-level\n\nexport type ValueGetter<TValue> = (el: HTMLElement | null) => TValue;\nexport type ValueSetter<TValue> = (el: HTMLElement | null, v: TValue) => void;\n\nexport type FieldConfig<TForm, TValue = unknown> = {\n    selector: string | HTMLElement;\n    validators?: ValidatorFn<TForm, TValue>[];\n    // Which DOM events should trigger validation for this field\n    validateOn?: Array<\"input\" | \"change\" | \"blur\">;\n    // Debounce async/sync validators per field (ms)\n    debounceMs?: number;\n    // Optional custom value coercion\n    getValue?: ValueGetter<TValue>;\n    setValue?: ValueSetter<TValue>;\n    // Where/how to show messages for this field\n    messageTarget?: string | HTMLElement | ((args: MessageRenderArgs) => void);\n    // If true, will set aria-invalid and link message with aria-describedby\n    a11y?: boolean;\n};\n\nexport type MessageRenderArgs = {\n    name: string;\n    messages: string[]; // resolved for the field\n    fieldEl: HTMLElement | null;\n    formEl: HTMLFormElement | null;\n};\n\nexport type FormConfig<TForm> = {\n    form: string | HTMLFormElement;\n    errorSummary?: string | HTMLElement | ((formMessages: string[], formEl: HTMLFormElement | null) => void);\n    validateOnSubmit?: boolean; // default true\n    preventSubmitIfInvalid?: boolean; // default true\n    scrollToFirstError?: boolean; // default false\n    formValidators?: FormValidatorFn<TForm>;\n    classes?: Partial<{\n        fieldInvalid: string; // applied to field element on invalid\n        fieldValid: string;   // applied to field element on valid\n        fieldTouched: string; // applied once user interacted\n    }>;\n};\n\nexport type FieldState = {\n    touched: boolean;\n    dirty: boolean;\n    messages: string[];\n    validating: boolean;\n    valid: boolean; // latest\n};\n\nexport type CreatedFormValidator<TForm> = {\n    // read-only snapshot\n    readonly formEl: HTMLFormElement | null;\n    readonly fields: Readonly<Record<keyof TForm & string, HTMLElement | null>>;\n\n    validateField: (name: keyof TForm & string) => Promise<boolean>;\n    validateForm: () => Promise<boolean>;\n\n    setErrors: (\n        fieldErrors: Partial<Record<keyof TForm & string, string[]>>, // server field errors\n        formErrors?: string[]\n    ) => void;\n\n    clearErrors: () => void;\n\n    getData: () => TForm;\n    setValue: <K extends keyof TForm & string>(name: K, value: TForm[K]) => void;\n\n    touch: (name: keyof TForm & string) => void;\n    reset: () => void;\n    destroy: () => void;\n};\n\n// -----------------------------------------------------------\n// Utilities\n// -----------------------------------------------------------\nconst isHTMLElement = (o: any): o is HTMLElement => o && typeof o === \"object\" && \"nodeType\" in o;\nconst el = <T extends HTMLElement>(root: ParentNode, sel: string): T | null => root.querySelector(sel);\nconst asEl = (x: string | HTMLElement | null | undefined): HTMLElement | null =>\n    !x ? null : typeof x === \"string\" ? document.querySelector(x) : x;\n\nconst DEFAULT_CLASSES = {\n    fieldInvalid: \"fv-invalid\",\n    fieldValid: \"fv-valid\",\n    fieldTouched: \"fv-touched\",\n};\n\nconst DEFAULT_SUMMARY_RENDERER = (summaryEl: HTMLElement | null, messages: string[]) => {\n    if (!summaryEl) return;\n    const isList = summaryEl.tagName === \"UL\" || summaryEl.tagName === \"OL\";\n    summaryEl.classList.toggle(\"hidden\", messages.length === 0);\n    if (isList) {\n        summaryEl.innerHTML = messages.map((m) => `<li>${m}</li>`).join(\"\");\n    } else {\n        summaryEl.innerHTML = messages.join(\"<br>\");\n    }\n};\n\nconst DEFAULT_FIELD_RENDERER = (target: HTMLElement | null, messages: string[]) => {\n    if (!target) return;\n    const isList = target.tagName === \"UL\" || target.tagName === \"OL\";\n    target.classList.toggle(\"hidden\", messages.length === 0);\n    if (isList) {\n        target.innerHTML = messages.map((m) => `<li>${m}</li>`).join(\"\");\n    } else {\n        target.innerHTML = messages.join(\"<br>\");\n    }\n};\n\nconst debounce = <T extends (...args: any[]) => any>(fn: T, ms = 200) => {\n    let t: number | undefined;\n    const debounced = (...args: Parameters<T>) => {\n        if (t) window.clearTimeout(t);\n        t = window.setTimeout(() => fn(...args), ms);\n    };\n    (debounced as any).flush = () => { if (t) { window.clearTimeout(t); t = undefined; fn(); } };\n    return debounced as T & { flush: () => void };\n};\n\n// -----------------------------------------------------------\n// Core factory\n// -----------------------------------------------------------\nexport function createFormValidator<TForm extends Record<string, any>>(\n    formConfig: FormConfig<TForm>,\n    fieldsConfig: { [K in keyof TForm & string]: FieldConfig<TForm, TForm[K]> },\n    options?: { onValidationChange?: (isValid: boolean) => void }\n): CreatedFormValidator<TForm> {\n    const formEl = asEl(formConfig.form) as HTMLFormElement | null;\n    const classes = { ...DEFAULT_CLASSES, ...(formConfig.classes || {}) };\n    const validateOnSubmit = formConfig.validateOnSubmit !== false; // default true\n    const preventSubmitIfInvalid = formConfig.preventSubmitIfInvalid !== false; // default true\n    const onValidationChange = options?.onValidationChange;\n\n    // Prepare fields\n    const fieldElements: Record<string, HTMLElement | null> = {};\n    const fieldStates: Record<string, FieldState> = {};\n    const fieldDebouncers: Record<string, ((() => void) & { flush: () => void }) | null> = {};\n    let formMessages: string[] = [];\n\n    for (const name of Object.keys(fieldsConfig)) {\n        const cfg = fieldsConfig[name as keyof TForm & string];\n        const target = typeof cfg.selector === \"string\" ? el<HTMLElement>(document, cfg.selector) : cfg.selector;\n        fieldElements[name] = target ?? null;\n        fieldStates[name] = { touched: false, dirty: false, messages: [], validating: false, valid: true };\n        fieldDebouncers[name] = cfg.debounceMs ? debounce(() => void 0, cfg.debounceMs) : null; // placeholder; per-field we'll use inline debouncing\n    }\n\n    // Resolve per-field message target\n    function resolveFieldMessageTarget(cfg: FieldConfig<TForm, any>): HTMLElement | null | ((args: MessageRenderArgs) => void) {\n        if (!cfg.messageTarget) return null;\n        if (typeof cfg.messageTarget === \"function\") return cfg.messageTarget;\n        return asEl(cfg.messageTarget);\n    }\n\n    // Read / write values\n    const getValue = <K extends keyof TForm & string>(name: K): TForm[K] => {\n        const cfg = fieldsConfig[name];\n        const elRef = fieldElements[name];\n        if (cfg.getValue) return cfg.getValue(elRef);\n        if (!elRef) return undefined as unknown as TForm[K];\n        // default coercion for common input types\n        if (elRef instanceof HTMLInputElement) {\n            const type = elRef.type;\n            if (type === \"checkbox\") return (!!elRef.checked) as unknown as TForm[K];\n            if (type === \"number\" || type === \"range\") return (elRef.value === \"\" ? undefined : Number(elRef.value)) as unknown as TForm[K];\n            return elRef.value as unknown as TForm[K];\n        }\n        if (elRef instanceof HTMLTextAreaElement) return elRef.value as unknown as TForm[K];\n        if (elRef instanceof HTMLSelectElement) return elRef.value as unknown as TForm[K];\n        return (elRef as any).value as TForm[K];\n    };\n\n    const setValue = <K extends keyof TForm & string>(name: K, value: TForm[K]) => {\n        const cfg = fieldsConfig[name];\n        const elRef = fieldElements[name];\n        if (cfg.setValue) return cfg.setValue(elRef, value);\n        if (!elRef) return;\n        if (elRef instanceof HTMLInputElement || elRef instanceof HTMLTextAreaElement || elRef instanceof HTMLSelectElement) {\n            if ((elRef as HTMLInputElement).type === \"checkbox\" && typeof value === \"boolean\") {\n                (elRef as HTMLInputElement).checked = value;\n            } else {\n                (elRef as any).value = value as any;\n            }\n        } else {\n            (elRef as any).value = value as any;\n        }\n    };\n\n    const getFormData = (): TForm => {\n        const data = {} as TForm;\n        for (const name of Object.keys(fieldsConfig) as Array<keyof TForm & string>) {\n            (data as any)[name] = getValue(name);\n        }\n        return data;\n    };\n\n    // Rendering helpers\n    const summaryTarget = typeof formConfig.errorSummary === \"function\" || !formConfig.errorSummary\n        ? formConfig.errorSummary\n        : asEl(formConfig.errorSummary);\n\n    function renderSummary(messages: string[]) {\n        if (typeof summaryTarget === \"function\") {\n            summaryTarget(messages, formEl);\n        } else {\n            DEFAULT_SUMMARY_RENDERER(summaryTarget as HTMLElement | null, messages);\n        }\n    }\n\n    function renderField(name: string) {\n        const cfg = fieldsConfig[name as keyof TForm & string];\n        const target = resolveFieldMessageTarget(cfg);\n        const messages = fieldStates[name].messages;\n\n        const fieldEl = fieldElements[name];\n        if (cfg.a11y !== false && fieldEl) {\n            fieldEl.setAttribute(\"aria-invalid\", String(messages.length > 0));\n            // link describedby if we have an element target\n            if (target && isHTMLElement(target)) {\n                const id = target.id || `${String(name)}-error`;\n                target.id = id;\n                fieldEl.setAttribute(\"aria-describedby\", id);\n            }\n        }\n\n        if (typeof target === \"function\") {\n            target({ name, messages, fieldEl, formEl });\n        } else {\n            DEFAULT_FIELD_RENDERER(target as HTMLElement | null, messages);\n        }\n\n        // Classes\n        if (fieldEl) {\n            fieldEl.classList.toggle(classes.fieldInvalid, messages.length > 0);\n            fieldEl.classList.toggle(classes.fieldValid, messages.length === 0 && fieldStates[name].touched);\n        }\n    }\n\n    function collectAllMessages(): string[] {\n        return [\n            ...Object.values(fieldStates).flatMap(s => s.messages),\n            ...formMessages\n        ];\n    }\n\n    let lastIsValid: boolean | undefined;\n\n    function notifyIfChanged() {\n        const currentIsValid = Object.values(fieldStates).every((s: FieldState) => s.valid && !s.validating) && formMessages.length === 0;\n        if (currentIsValid !== lastIsValid) {\n            lastIsValid = currentIsValid;\n            onValidationChange?.(currentIsValid);\n        }\n    }\n\n    async function runValidatorsForField(name: keyof TForm & string): Promise<string[]> {\n        const cfg = fieldsConfig[name];\n        const validators = cfg.validators || [];\n        const value = getValue(name);\n        const formData = getFormData();\n        const fieldEl = fieldElements[name];\n\n        const messages: string[] = [];\n        for (const fn of validators) {\n            const res = await fn({ name, value, formData, fieldEl, formEl });\n            if (!res || res.valid === true) continue;\n            messages.push(res.message);\n        }\n        return messages;\n    }\n\n    async function validateField(name: keyof TForm & string): Promise<boolean> {\n        const cfg = fieldsConfig[name];\n        const state = fieldStates[name];\n\n        state.touched = true;\n        const exec = async () => {\n            state.validating = true;\n            const messages = await runValidatorsForField(name);\n            state.messages = messages;\n            state.valid = messages.length === 0;\n            state.validating = false;\n            renderField(name);\n            renderSummary(collectAllMessages());\n            notifyIfChanged();\n            return state.valid;\n        };\n\n        if (cfg.debounceMs && cfg.debounceMs > 0) {\n            return new Promise((resolve) => {\n                const d = debounce(async () => resolve(await exec()), cfg.debounceMs);\n                d();\n            });\n        }\n        return exec();\n    }\n\n    async function validateForm(): Promise<boolean> {\n        const results = await Promise.all(\n            (Object.keys(fieldsConfig) as Array<keyof TForm & string>).map((n) => validateField(n))\n        );\n\n        // Run form-level validators (cross-field) if provided\n        let formLevelMessages: string[] = [];\n        if (formConfig.formValidators) {\n            const res = await formConfig.formValidators({ formData: getFormData(), formEl });\n            formLevelMessages = res.filter(r => r && !r.valid).map(r => r.message);\n        }\n        formMessages = formLevelMessages;\n\n        const allMessages = collectAllMessages();\n        renderSummary(allMessages);\n        notifyIfChanged();\n\n        if (formConfig.scrollToFirstError && allMessages.length > 0) {\n            const firstInvalid = Object.keys(fieldStates).find((n) => fieldStates[n].messages.length > 0);\n            const elRef = firstInvalid ? fieldElements[firstInvalid] : null;\n            elRef?.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n            elRef?.focus({ preventScroll: true });\n        }\n\n        return results.every(Boolean) && formMessages.length === 0;\n    }\n\n    function setErrors(\n        fieldErrors: Partial<Record<keyof TForm & string, string[]>>,\n        formErrors: string[] = []\n    ) {\n        // Assign messages\n        for (const name of Object.keys(fieldsConfig) as Array<keyof TForm & string>) {\n            const msgs = fieldErrors[name] || [];\n            fieldStates[name].messages = msgs;\n            fieldStates[name].valid = msgs.length === 0;\n            // Mark as touched so styling appears\n            fieldStates[name].touched = true;\n            renderField(name);\n        }\n        formMessages = formErrors;\n        renderSummary(collectAllMessages());\n        notifyIfChanged();\n    }\n\n    function clearErrors() {\n        for (const name of Object.keys(fieldStates)) {\n            fieldStates[name].messages = [];\n            fieldStates[name].valid = true;\n            renderField(name);\n        }\n        formMessages = [];\n        renderSummary([]);\n        notifyIfChanged();\n    }\n\n    function touch(name: keyof TForm & string) {\n        fieldStates[name].touched = true;\n        const elRef = fieldElements[name];\n        elRef?.classList.add(classes.fieldTouched);\n    }\n\n    function reset() {\n        for (const name of Object.keys(fieldStates)) {\n            fieldStates[name] = { touched: false, dirty: false, messages: [], validating: false, valid: true };\n            renderField(name);\n        }\n        formMessages = [];\n        renderSummary([]);\n        notifyIfChanged();\n    }\n\n    function destroy() {\n        // remove listeners\n        if (formEl && validateOnSubmit && preventSubmitIfInvalid) {\n            formEl.removeEventListener(\"submit\", onSubmit);\n        }\n        for (const name of Object.keys(fieldsConfig) as Array<keyof TForm & string>) {\n            const elRef = fieldElements[name];\n            const cfg = fieldsConfig[name];\n            const bound = boundHandlers[name];\n            if (elRef && bound) {\n                for (const ev of cfg.validateOn || []) {\n                    elRef.removeEventListener(ev, bound);\n                }\n            }\n        }\n    }\n\n    // Event binding\n    const boundHandlers: Record<string, (e: Event) => void> = {};\n    for (const name of Object.keys(fieldsConfig) as Array<keyof TForm & string>) {\n        const cfg = fieldsConfig[name];\n        const elRef = fieldElements[name];\n        if (!elRef) continue;\n\n        const handler = async () => {\n            touch(name);\n            await validateField(name);\n        };\n        boundHandlers[name] = handler;\n\n        for (const ev of cfg.validateOn || []) {\n            elRef.addEventListener(ev, handler);\n        }\n    }\n\n    async function onSubmit(e: Event) {\n        if (!preventSubmitIfInvalid) return;\n        const ok = await validateForm();\n        if (!ok) {\n            e.preventDefault();\n            e.stopPropagation();\n        }\n    }\n\n    if (formEl && validateOnSubmit) {\n        formEl.addEventListener(\"submit\", onSubmit);\n    }\n\n    return {\n        get formEl() { return formEl; },\n        get fields() { return Object.fromEntries(Object.entries(fieldElements)) as any; },\n\n        validateField: (n) => validateField(n),\n        validateForm,\n\n        setErrors,\n        clearErrors,\n\n        getData: () => getFormData(),\n        setValue,\n\n        touch,\n        reset,\n        destroy,\n    } as const;\n}\n\n// -----------------------------------------------------------\n// Built-in validators (v.*)\n// -----------------------------------------------------------\nexport const v = {\n    required<TForm, TValue>(message = \"This field is required.\"): ValidatorFn<TForm, TValue> {\n        return ({ value }) => {\n            if (value === undefined || value === null) return { valid: false, message } as const;\n            if (typeof value === \"string\" && value.trim() === \"\") return { valid: false, message } as const;\n            if (Array.isArray(value) && value.length === 0) return { valid: false, message } as const;\n            return { valid: true } as const;\n        };\n    },\n\n    pattern<TForm>(regex: RegExp, message = \"Invalid format.\"): ValidatorFn<TForm, string> {\n        return ({ value }) => {\n            if (typeof value !== \"string\") return { valid: true } as const;\n            return regex.test(value) ? { valid: true } as const : { valid: false, message } as const;\n        };\n    },\n\n    email<TForm>(message = \"Invalid email address.\"): ValidatorFn<TForm, string> {\n        // RFC 5322-lite\n        const re = /^(?:[a-zA-Z0-9_'^&\\-]+(?:\\.[a-zA-Z0-9_'^&\\-]+)*)@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,}$/;\n        return ({ value }) => {\n            if (typeof value !== \"string\" || value.trim() === \"\") return { valid: true } as const; // let required handle empties\n            return re.test(value.trim()) ? { valid: true } as const : { valid: false, message } as const;\n        };\n    },\n\n    minLength<TForm>(len: number, message?: string): ValidatorFn<TForm, string> {\n        return ({ value }) => {\n            if (typeof value !== \"string\") return { valid: true } as const;\n            if (value.length < len) return { valid: false, message: message || `Must be at least ${len} characters.` } as const;\n            return { valid: true } as const;\n        };\n    },\n\n    maxLength<TForm>(len: number, message?: string): ValidatorFn<TForm, string> {\n        return ({ value }) => {\n            if (typeof value !== \"string\") return { valid: true } as const;\n            if (value.length > len) return { valid: false, message: message || `Must be at most ${len} characters.` } as const;\n            return { valid: true } as const;\n        };\n    },\n\n    equalsField<TForm, K extends keyof TForm & string>(other: K, message = \"Values do not match.\"): ValidatorFn<TForm, any> {\n        return ({ formData }) => {\n            return { valid: true } as const; // actual comparison done below via closure\n        };\n    },\n\n    sameAs<TForm, K extends keyof TForm & string>(other: K, message = \"Values do not match.\"): ValidatorFn<TForm, any> {\n        return ({ value, formData }) => {\n            return (value === (formData as any)[other]) ? { valid: true } as const : { valid: false, message } as const;\n        };\n    },\n\n    numberRange<TForm>(min?: number, max?: number, message?: string): ValidatorFn<TForm, number | undefined> {\n        return ({ value }) => {\n            if (value === undefined || value === null || Number.isNaN(value)) return { valid: true } as const;\n            if (typeof min === \"number\" && value < min) return { valid: false, message: message || `Must be ≥ ${min}.` } as const;\n            if (typeof max === \"number\" && value > max) return { valid: false, message: message || `Must be ≤ ${max}.` } as const;\n            return { valid: true } as const;\n        };\n    },\n\n    passwordRules<TForm>(opts: { upper?: boolean; lower?: boolean; digit?: boolean; special?: boolean; minUnique?: number } = {}): ValidatorFn<TForm, string> {\n        const re = {\n            upper: /[A-Z]/,\n            lower: /[a-z]/,\n            digit: /\\d/,\n            special: /[^A-Za-z0-9\\s]/,\n        };\n        return ({ value }) => {\n            if (typeof value !== \"string\" || value.length === 0) return { valid: true } as const; // let required/minLength manage empties\n            const missing: string[] = [];\n            if (opts.upper && !re.upper.test(value)) missing.push(\"an uppercase letter\");\n            if (opts.lower && !re.lower.test(value)) missing.push(\"a lowercase letter\");\n            if (opts.digit && !re.digit.test(value)) missing.push(\"a digit\");\n            if (opts.special && !re.special.test(value)) missing.push(\"a special character\");\n            if (typeof opts.minUnique === \"number\") {\n                const unique = new Set(value.split(\"\")).size;\n                if (unique < opts.minUnique) missing.push(`${opts.minUnique} unique characters`);\n            }\n            if (missing.length) return { valid: false, message: `Password must include: ${missing.join(\", \")}.` } as const;\n            return { valid: true } as const;\n        };\n    },\n\n    custom<TForm, TValue>(fn: ValidatorFn<TForm, TValue>): ValidatorFn<TForm, TValue> { return fn; },\n};\n\n// -----------------------------------------------------------\n// Optional: simple helpers to wire common per-field message containers\n// -----------------------------------------------------------\nexport function belowFieldMessage(targetSelector: string): (args: MessageRenderArgs) => void {\n    const targetEl = asEl(targetSelector);\n    return ({ messages }) => DEFAULT_FIELD_RENDERER(targetEl, messages);\n}\n\nexport function toSummary(summarySelector: string): (messages: string[], formEl: HTMLFormElement | null) => void {\n    const summaryEl = asEl(summarySelector);\n    return (messages) => DEFAULT_SUMMARY_RENDERER(summaryEl, messages);\n}",
    "\nexport const PATH = {\n    AUTH: {\n        LOGIN: '/login'\n    },\n    USER: {\n        ROOT: '/user'\n    },\n    DASHBOARD: {\n        INDEX: '/'\n    },\n    CATEGORIES: {\n        INDEX: '/categories'\n    },\n    SETTINGS: {\n        INDEX: \"/settings\"\n    },\n    STATIC: {\n        ROOT: '/static',\n        CSS: '/static/css',\n        LIB: '/static/lib',\n        IMAGES: \"/static/images\"\n    },\n} as const;\n\nexport const ALLOWED_PATHS = [\"/login\", \"/static\"];\nexport const COOKIES_NAME = \"session\";",
    "\n// Utility function to debounce input validation\nexport const debounce = <T extends (...args: any[]) => void>(fn: T, delay: number) => {\n    let timeoutId: NodeJS.Timeout;\n    return (...args: Parameters<T>) => {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => fn(...args), delay);\n    };\n};\n\n/**\n * Initializes password input toggle buttons inside the given root element.\n *\n * The following elements are required inside each toggle element:\n * - an `<input>` element with type \"password\" or \"text\"\n * - a `<button>` element containing two `<svg>` elements (order matters: open first, close second)\n *\n * Toggles the input type and displays/hides the icons accordingly.\n *\n * @param root - the root element to search for toggle elements (default: `document`)\n */\nexport const initPasswordToggles = (root: Document | HTMLElement = document) => {\n    root.querySelectorAll<HTMLElement>(\"[data-password-with-toggle]\").forEach(wrapper => {\n        const input = wrapper.querySelector<HTMLInputElement>(\n            \"input[type='password'], input[type='text']\"\n        );\n        const button = wrapper.querySelector<HTMLButtonElement>(\"button\");\n\n        if (!input || !button) return;\n\n        // Find both icons inside button (order matters: open first, close second)\n        const icons = button.querySelectorAll<SVGElement>(\"svg\");\n\n        button.addEventListener(\"click\", () => {\n            const isPassword = input.type === \"password\";\n            input.type = isPassword ? \"text\" : \"password\";\n\n            if (icons.length >= 2) {\n                icons[0].style.display = isPassword ? \"none\" : \"\";\n                icons[1].style.display = isPassword ? \"\" : \"none\";\n            }\n        });\n\n        // Initialize icons (show open-eye first, hide closed-eye)\n        if (icons.length >= 2) {\n            icons[0].style.display = \"\";\n            icons[1].style.display = \"none\";\n        }\n    });\n}\n\n// global event listener to handle button loading state\nexport const initFetchableButtonsGlobalState = () => {\n    document\n        .querySelectorAll(\"button[data-fetchable=true]\") // select only fetchable buttons\n        .forEach(button => {\n            button.addEventListener(\"click\", () => setButtonLoading(button as HTMLButtonElement));\n        });\n}\n\n\n// Utility function to handle button loading state\nexport const setButtonLoading = (button: HTMLButtonElement) => {\n    button.setAttribute(\"data-fetch-status\", \"loading\");\n    button.disabled = true;\n}\n\nexport const setButtonIdle = (button: HTMLButtonElement) => {\n    button.setAttribute(\"data-fetch-status\", \"idle\");\n    button.disabled = false;\n}",
    "import { ERROR_NAMES, type FailureResponse } from '@/utils/response.util';\nimport { createFormValidator, v } from './utils/vanilla-validator';\nimport { PATH } from '@/constants';\nimport { initPasswordToggles, setButtonIdle, setButtonLoading } from './utils';\n\n// Initialize password toggle buttons\ninitPasswordToggles()\n\n// ======================\n// Types\n// ======================\ninterface LoginFormData {\n    email: string;\n    password: string;\n}\n\n// ======================\n// DOM Cache\n// ======================\nconst loginForm = document.querySelector<HTMLFormElement>('#login-form');\nconst submitButton = document.querySelector<HTMLButtonElement>('button[type=\"submit\"]');\nconst errorContainer = document.querySelector<HTMLUListElement>('ul#response-errors');\n\n// ======================\n// Error Rendering\n// ======================\nconst showErrors = (messages: string[]) => {\n    if (!errorContainer) {\n        console.warn('Error container <ul id=\"response-errors\"> not found.');\n        return;\n    }\n\n    errorContainer.innerHTML = ''; // Clear old errors\n\n    messages.forEach(msg => {\n        const li = document.createElement('li');\n        li.textContent = msg;\n        errorContainer.appendChild(li);\n    });\n\n    errorContainer.classList.remove('hidden');\n};\n\nconst clearErrors = () => {\n    if (errorContainer) {\n        errorContainer.innerHTML = '';\n        errorContainer.classList.add('hidden');\n    }\n};\n\n// ======================\n// Validator Setup\n// ======================\nconst formValidator = () =>\n    createFormValidator(\n        {\n            form: '#login-form',\n            errorSummary: '#form-errors',\n            validateOnSubmit: true,\n            scrollToFirstError: true,\n            preventSubmitIfInvalid: true,\n        },\n        {\n            email: {\n                selector: 'input[type=\"email\"], input[name=\"email\"]',\n                validateOn: ['input', 'blur'],\n                debounceMs: 500,\n                validators: [v.required('Email is required.'), v.email()],\n                a11y: true,\n            },\n            password: {\n                selector: 'input[type=\"password\"]',\n                validateOn: ['input', 'blur'],\n                debounceMs: 500,\n                validators: [\n                    v.minLength(8),\n                    v.passwordRules({ upper: true, lower: true, digit: true, special: true }),\n                ],\n                a11y: true,\n            },\n        } as const,\n        {\n            onValidationChange: (isValid) => {\n                if (submitButton) {\n                    submitButton.disabled = !isValid;\n                }\n            },\n        }\n    );\n\n// ======================\n// API Call\n// ======================\nconst loginRequest = async (data: LoginFormData): Promise<Response> => {\n    return fetch(PATH.AUTH.LOGIN, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(data),\n    });\n};\n\n// ======================\n// Submit Handler\n// ======================\n\nconst handleSubmit = (fv: ReturnType<typeof formValidator>) => async (e: Event) => {\n    e.preventDefault();\n    clearErrors();\n\n    setButtonLoading(submitButton!);\n    const formData = fv.getData();\n\n    try {\n        const response = await loginRequest(formData);\n        const json = await response.json();\n\n        if (!response.ok) {\n            setButtonIdle(submitButton!);\n            const failure = json as FailureResponse<string[]>;\n            console.info('Login error:', failure);\n\n            if (failure.name === ERROR_NAMES.VALIDATION_ERROR) {\n                showErrors(failure.data ?? []);\n            } else {\n                showErrors(['Invalid email or password.']);\n            }\n            return;\n        }\n\n        console.log('Login successful');\n        window.location.replace(PATH.DASHBOARD.INDEX);\n    } catch (err) {\n        setButtonIdle(submitButton!);\n        const msg = err instanceof Error ? err.message : 'Login failed, please try again.';\n        showErrors([msg]);\n    }\n};\n\n// ======================\n// Init\n// ======================\ndocument.addEventListener('DOMContentLoaded', () => {\n    if (!loginForm) {\n        console.warn('Login form not found.');\n        return;\n    }\n\n    const fv = formValidator();\n    loginForm.addEventListener('submit', handleSubmit(fv));\n});\n"
  ],
  "mappings": "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",
  "debugId": "C9EA470483B93AFF64756E2164756E21",
  "names": []
}